#+TITLE: CS Plans

* Съдържание :toc:
- [[#преговор][Преговор]]
  - [[#архитектура-на-съвременния-компютър---стр-4-фигура-1][Архитектура на съвременния компютър - стр 4 фигура 1]]
  - [[#хардуер-физическа-част][Хардуер (физическа част)]]
  - [[#софтуер][Софтуер]]
  - [[#функции-на-операционната-система][Функции на операционната система]]
- [[#езици-на-програмиране][Езици на програмиране]]
  - [[#машинен-език---01][Машинен език - 0/1]]
  - [[#асемблерен-език][Асемблерен език]]
  - [[#алгоритмичен-език][Алгоритмичен език]]
  - [[#синтаксис-и-семантика-на-език-за-програмиране][Синтаксис и семантика на език за програмиране]]
  - [[#обектно-ориентирано-програмиране][Обектно-ориентирано програмиране]]
- [[#инструменти-и-среди-за-програмиране][Инструменти и среди за програмиране]]
  - [[#програмни-проекти][Програмни проекти]]
  - [[#етапи-при-разработване-на-програмен-проект][Етапи при разработване на програмен проект]]
  - [[#инструменти-за-създаване-на-програми][Инструменти за създаване на програми]]
  - [[#среда-за-програмиране][Среда за програмиране]]
- [[#интегрирана-среда-за-програмиране-visual-studio][Интегрирана среда за програмиране Visual Studio]]
  - [[#проект-и-решение][Проект и решение]]
  - [[#стандартен-вход-и-изход][Стандартен вход и изход]]
- [[#елементи-на-програма-на-c][Елементи на програма на C#]]
  - [[#какво-представляват-програмите][Какво представляват програмите]]
  - [[#какво-представляват-думите][Какво представляват думите]]
  - [[#ключови-думи][Ключови думи]]
  - [[#имена-идентификатори-на-елементите-на-език-c][Имена (идентификатори) на елементите на език C#]]
  - [[#данни][Данни]]
  - [[#деклариране-на-променливи][Деклариране на променливи]]
  - [[#структура-на-програмата][Структура на програмата]]
  - [[#знаци][Знаци]]
  - [[#коментари][Коментари]]
  - [[#оформяне-на-програмата][Оформяне на програмата]]
- [[#основни-типове-операции-и-оператори][Основни типове операции и оператори]]
  - [[#видове-операции][Видове операции]]
  - [[#артиметични-операции-с-цели-числа][Артиметични операции с цели числа:]]
  - [[#аритметични-операции-с-дробни-числа][Аритметични операции с дробни числа:]]
  - [[#аритметичен-израз][Аритметичен израз]]
  - [[#операция-за-присвояване-][Операция за присвояване: =]]
- [[#изчислителни-процеси-линейни-процеси][Изчислителни процеси. Линейни процеси]]
  - [[#език-за-специфициране-uml][Език за специфициране UML]]
  - [[#uml-диаграма-на-изчислителен-процес][UML диаграма на изчислителен процес]]
  - [[#видове-изчислителни-процеси][Видове изчислителни процеси]]
  - [[#медоти-за-избягване-на-повторението-на-код][Медоти за избягване на повторението на код]]
  - [[#методът-parse][Методът Parse]]
  - [[#класът-math][Класът Math]]
  - [[#линейни-изчилистелни-процеси---упр][Линейни изчилистелни процеси - упр]]
- [[#сравнение-и-логически-операции][Сравнение и логически операции]]
  - [[#логически-стойности---boolean][Логически стойности - boolean]]
  - [[#операции-за-сравняване][Операции за сравняване]]
  - [[#логически-операции][Логически операции]]
  - [[#логически-изрази---сраница-48-фиг-4][Логически изрази - сраница 48 фиг. 4]]
- [[#разклонени-изчислителни-процеси][Разклонени изчислителни процеси]]
  - [[#условен-оператор---if][Условен оператор - if]]
  - [[#оператор-за-многовариантен-избор][Оператор за многовариантен избор]]
- [[#циклични-изчислителни-процеси][Циклични изчислителни процеси]]
- [[#обекти-и-класове-от-обекти][Обекти и класове от обекти]]
  - [[#обекти][Обекти]]
  - [[#класове-от-обекти][Класове от обекти]]
  - [[#инстанция-екземпляр-на-класа][Инстанция (Екземпляр) на класа]]
  - [[#атрибути-на-класа][Атрибути на класа]]
  - [[#методи-на-класа][Методи на класа]]
  - [[#пример-за-клас][Пример за клас]]
  - [[#изисквания-при-създаване-на-клас][Изисквания при създаване на клас]]
  - [[#uml-диаграма-на-клас---стр-56фиг-2][UML диаграма на клас - стр. 56/фиг. 2]]
  - [[#нива-на-абстракция][Нива на абстракция]]
- [[#класове][Класове]]
  - [[#дефиниране-на-клас-от-обекти][Дефиниране на клас от обекти]]
  - [[#създаване-на-обект-от-клас][Създаване на обект от клас]]
- [[#клас-с-контролирани-атрибути][Клас с контролирани атрибути]]
  - [[#дефиниране-на-клас-с-контролирани-атрибути][Дефиниране на клас с контролирани атрибути]]
  - [[#достъп-до-контролираните-атрибути][Достъп до контролираните атрибути]]
- [[#функции-и-методи][Функции и методи]]
  - [[#функции][Функции]]
  - [[#област-на-видимост-на-променливите][Област на видимост на променливите]]
  - [[#обектът-като-аргумент][Обектът като аргумент]]
- [[#конструктори][Конструктори]]
  - [[#конструктор-по-премълчаване][Конструктор по премълчаване]]
  - [[#конструктор-с-аргументи][Конструктор с аргументи]]
  - [[#конструктор-за-копиране][Конструктор за копиране]]
- [[#предаване-на-аргументи][Предаване на аргументи]]
  - [[#референции][Референции]]
  - [[#предаване-на-прараметри-по-стойност][Предаване на прараметри по стойност]]
  - [[#предаване-на-фактически-параметри-по-референция][Предаване на фактически параметри по референция]]
- [[#агрегатни-типове][Агрегатни типове]]
  - [[#структура-от-данни][Структура от данни]]
  - [[#агрегатни-типове-данни][Агрегатни типове данни]]
  - [[#едномерен-масив][Едномерен масив]]
  - [[#елементи-на-масива][Елементи на масива]]
  - [[#деклариране-на-едномерен-масив-и-заделяне-на-памет][Деклариране на едномерен масив и заделяне на памет]]
  - [[#задача][Задача]]
  - [[#статични-агрегатни-типове][Статични агрегатни типове]]
  - [[#динамични-аграгатни-типове][Динамични аграгатни типове]]
  - [[#списък][Списък]]
  - [[#основни-методи-за-работа-със-списък][Основни методи за работа със списък]]
  - [[#елемент-списъчна-кутия][Елемент списъчна кутия]]
- [[#файлове][Файлове]]
  - [[#потоци-от-данни][Потоци от данни]]
  - [[#systemio][System.IO]]
  - [[#физически-файл][Физически файл]]
  - [[#логически-файл][Логически файл]]
  - [[#записване-в-такстов-файл][Записване в такстов файл]]
  - [[#компонент-многоредова-текстова-кутия--richtextbox][Компонент многоредова текстова кутия / RichTextBox]]
  - [[#четене-от-текстов-файл][Четене от текстов файл]]
- [[#класът-string][Класът string]]
  - [[#свойства][Свойства]]
  - [[#методи-на-класът-string][Методи на класът string]]
  - [[#компонент-комбинирана-текстова-кутия--combobox][Компонент комбинирана текстова кутия / ComboBox]]
- [[#документиране-на-клас][Документиране на клас]]
  - [[#xml][XML]]
  - [[#автоматизирано-докуметиране-на-клас][Автоматизирано докуметиране на клас]]
  - [[#сериализация][Сериализация]]
  - [[#десериализация][Десериализация]]
  - [[#сериализиране-на-масив-от-инстанции][Сериализиране на масив от инстанции]]
- [[#капсулиране-статични-атрибути-и-методи][Капсулиране. Статични атрибути и методи]]
  - [[#капсулиране][Капсулиране]]
  - [[#модификатори][Модификатори]]
  - [[#достъп-до-класовете-и-членовете-на-класа][Достъп до класовете и членовете на класа]]
  - [[#статични-членове-на-клас][Статични членове на клас]]
  - [[#константи][Константи]]
- [[#йерархии-от-класове][Йерархии от класове]]
  - [[#наследяване][Наследяване]]
  - [[#пренаписване-на-методи][Пренаписване на методи]]
  - [[#модификаторът-protected][Модификаторът protected]]
  - [[#класът-object][Класът object]]
- [[#полиморфизъм][Полиморфизъм]]
  - [[#полиморфизъм-1][Полиморфизъм]]
  - [[#видове-полиморфизъм][Видове полиморфизъм]]
  - [[#преобразуване-нагоре][Преобразуване нагоре]]
  - [[#преобразуване-надолу][Преобразуване надолу]]
  - [[#предефиниране-на-операциите][Предефиниране на операциите]]

* Преговор
** Архитектура на съвременния компютър - стр 4 фигура 1
+ комуникационна шина
+ централен процесор
+ оперативна памет (RAM)

** Хардуер (физическа част)
*** Централен процесор
- електронно устройство, способно да изпълнява множество команди за работа
  с данни

*** Оперативна памет
- съхранява изпълняваната програма и данните, необходими за нейното
  изпълнени

*** Твърд диск

*** Входно-изходни устройства

*** Контролери
- специализирани процесори, които управляват входно-изходните усройства (звукова
  карта, видео карта, мрежова карта и др.)

** Софтуер
+ Системен софтуер - операционна система
+ Приложен софтуер

** Функции на операционната система
*** усъществяване на диалог с потребителя
- Основното предназначение на ОС е да създаде на потребителя условия за работа.
Това става чрез специализирани езици, наричани интерфейси.  Съвремениите ОС
предлагат два вида интерфейси - графичен и команден (буквенно-цифров).

*** управление на изпълнението на програми

*** управление на входно-изходните устройства

* Езици на програмиране
** Машинен език - 0/1

** Асемблерен език
- Асемблер - програма, която превежда от асемблерен на машинен език

** Алгоритмичен език
*** Транслатор - програма, която превежда от алгоритмичен на машинен език. Биват два вида:
+ Компилатор
+ Интерпретатор

** Синтаксис и семантика на език за програмиране
*** Синтаксис
- правилата, по които задължително трябва да се изписват конструкциите на
  езика за програмиране

*** Семантика
- смисълът, който се влага във всяка от конструкциите

** Обектно-ориентирано програмиране
- Създават се класове на еднотипни обекти от реалнотта, в които са вкючени
  описващите ги данни и методи за обичайните операции

* Инструменти и среди за програмиране
** Програмни проекти
- Проект наричаме всяко множество от дейности, което има точно определена цел
и трябва да доведе до получаване на очаквани резултати в рамките на определно
време и ресурси.

** Етапи при разработване на програмен проект
+ Анализ на задачата
+ Проектиране
+ Разработване - създаване на графичен дизаин, писане на код и цялостно
  изграждане на проекта
+ Документиране

** Инструменти за създаване на програми
+ Текстов редактор
+ Редактор за графичен интерфейс
+ Транслатор
+ Дебъгер
+ Други инструменти

** Среда за програмиране
- съвкупността от инструментални програми предназначени за създаване на
  нови програми
- Съвремената тенденция е да се интегрират всички елементи на системата за
  програмиране в едно цяло, наричано интегрирана среда за програмиране

* Интегрирана среда за програмиране Visual Studio
** Проект и решение
** Стандартен вход и изход

* Елементи на програма на C#
** Какво представляват програмите
- Текстове съставени от знаците на клавиатурната азбука

** Какво представляват думите
- Последователност от знаци които представляват съответните синтактични
  категории на езика

** Ключови думи
- Имат строго определено предназначение в езика, което не може да се променя
- страница 21, таблица

** Имена (идентификатори) на елементите на език C#
- Имената в C# са думи съставени от латински букви, цифри и знака за подчертаване,
започващи с латинска буква. За имена не могат да се използват ключови думи.

** Данни
+ константи (const) - полета от паметта, чието съдържание не се мени по
  време на програмта
+ поменливи (variable) - полета от паметта, чието съдържание се мени по
  време на програмата
+ литерали (literals) - константи, които се използват пряко в кода на
  програмата без да им се дават имена
#+begin_src csharp
int a = 1;
string b = "cat";
#+end_src
1 и "cat" са литерали.

** Деклариране на променливи
<тип> <име на променлива>

** Структура на програмата

** Знаци

** Коментари
+ коментар на един ред - //
+ коментар на няколко реда - /* */

** Оформяне на програмата

* Основни типове операции и оператори
** Видове операции
+ унарни
+ бинарни
+ други
** Артиметични операции с цели числа:
+ +
+ -
+ *
+ %
** Аритметични операции с дробни числа:
+ +
+ -
+ *
+ /
+ %
** Аритметичен израз
** Операция за присвояване: =
* Изчислителни процеси. Линейни процеси
** Език за специфициране UML
- Графичен език за специфициране и документиране на компонентите на софтуерна система
- Елементът на UML, в който се извършва всяко моделиране е диаграма
** UML диаграма на изчислителен процес
** Видове изчислителни процеси
+ линейни
+ разклонени
+ циклични
** Медоти за избягване на повторението на код
+ цикли
+ методи
** Методът Parse
** Класът Math
- съдържа методи за пресмятане на математически функции
** Линейни изчилистелни процеси - упр
Зад. Начертайте UML диаграма, която по зададени 2 числа изчилява и извежда периметърат и лицето на правоъгълник с тези параметри

* Сравнение и логически операции
** Логически стойности - boolean
** Операции за сравняване
+ ==
+ >
+ <
+ >=
+ <=
+ !=
** Логически операции
+ && (логическо и / логическо умножение)
+ || (логическо или / логическо събиране)
+ !
** Логически изрази - сраница 48 фиг. 4

* Разклонени изчислителни процеси
** Условен оператор - if
#+begin_src csharp
if(<condition>)
{
    <code>
}
else
{
    <code>
}
#+end_src

** Оператор за многовариантен избор
#+begin_src csharp
switch(<variable>){
case <case>:
    <code>;
    break;
}
#+end_src

* Циклични изчислителни процеси
+ Операции за цикъл с параметър
+ Оператор за цикъл с предусловие
+ Оператор за цикъл с постусловие
* Обекти и класове от обекти
** Обекти
В ООП се създават компютърни модели на реални или абстрактни обекти.
За всеки компютърен модел се добавят определени характеристики на обектите
и методи, чрез които се обработват обектите.
#+begin_src csharp
class Person {
}
#+end_src

** Класове от обекти
- всички еднотипни обекти с еднакви атрибути и методи.
** Инстанция (Екземпляр) на класа
- всеки конкретен обект от реалността със специфични стойности на атрибутите.
** Атрибути на класа
- това са характеристиките на обектите от класа и се наритат член-променливи
  на класа.
** Методи на класа
- функции извършващи необходимите обработки на обектите от класа. Наричат
  се още член-функции на класа.
** Пример за клас
+ клас човек (реален обект)
+ клас дроб, точка (абстрактен обект)
** Изисквания при създаване на клас
+ достатъчност - само необходимите/използвани характеристики
+ пълнота - всички необходими за задачата характеристики
+ простота - да се разбира, максимално опростен
** UML диаграма на клас - стр. 56/фиг. 2
** Нива на абстракция

* Класове
** Дефиниране на клас от обекти
!NB Дефинира се извън клас Program
#+begin_quote
public class <Име на клас> {
    [public/private] <тип> <име на атрибут>;
    [public/private] <тип за връщане> <име на метод>([<тип> <име на параметър>])
    {
        <код>
    }
}
#+end_quote

#+begin_src csharp
public class Person {
    public string name;
    public int age;
    public bool isMale;
}
#+end_src

** Създаване на обект от клас
#+begin_quote
<клас> <име на обект> = new <клас>();
#+end_quote

#+begin_src csharp
Person p1 = new Person();
p1.name = "Jiaqi";
p1.age = 17;
p1.isMale = true;
#+end_src

* Клас с контролирани атрибути
** Дефиниране на клас с контролирани атрибути
Използва се, когато програмистът не иска програмите, които използват класа да
имат пряк достъп до атрибутите му. Атрибутите на класа трябва да се дефинират
като private
** Достъп до контролираните атрибути
*** Създаване на setter
- необходимо е, за да можем да записваме стойност в контролираните атрибути
*** Синтаксис на конструкцията за създаване на setter
#+begin_comment
public <type> <public name>
{
    set { this.<private name> = value }
}
#+end_comment

#+begin_src csharp
public string Brand {
    set { this.brand = value; }
}
#+end_src

*** Създаване на getter
- необходимо е, за да можем достъпваме записаните стойности в контролираните
атрибути
*** Синтаксис на конструкцията за създаване на getter
#+begin_comment
public <type> <public name>
{
    get { return this.<private name> }
}
#+end_comment
#+begin_src csharp
public string Brand {
    get { return this.brand; }
}
#+end_src

*** Създаване на setter и getter
#+begin_src csharp
public string Brand {
    set { this.brand = value; }
    get { return this.brand; }
}
#+end_src

* Функции и методи
** Функции
- създават се, когато се налага част от програмният код да се използва многократно
*** синтаксис за създаване на функция
#+begin_quote
<модификатор> <тип на резултат> <Име на метод>([<тип> <име на параметър>, <тип> <име на 2ри параметър>])
{
    ...
    return ...;
}
#+end_quote

#+begin_src csharp
public double SquareArea(double a)
{
    return a*a;
}
double s = SquareArea(4); // s = 16;
#+end_src

*** видове функции:
+ с параметри и без параметри
+ които връщат стойност и които не връщат стойност
*** претоварване на имената (method overloading)
- можем да именуваме по един и същи начин две различни по съдържание функции,
  които имат различна сигнатура
*** сигнатура на функция
- уникалната комбинация от типове и имена на параметерите.
*** полиморфизъм
- еднакво именувани функциии звършват различни неща
** Област на видимост на променливите
+ глобални
+ локални
** Обектът като аргумент

* Конструктори
** Конструктор по премълчаване
- Метод за създаване на инстанция на даден клас. Той се създава по подразбиране
  при дефинирането на класа. Занулява всички атрибути на класа.
- Вид на конструктор: <Клас>();
  #+begin_src csharp
  Car myCar = new Car();
  #+end_src
- Предифиниране на стандартния конструктор
  #+begin_src csharp
  public Car() {

      this.model = "Model X";
      this.year = 2020;
      this.engineVolume = 500;
  }
  #+end_src

** Конструктор с аргументи
- Специален метод за създаване на инстанция на даден клас, задаваща начални
  стойности на атрибутите на тоя обект.

** Конструктор за копиране
- конструктор, чиято цел е да присвои стойностите на атрибута от един обект
  на друг
- дефиниране на копиращ конструктор
  #+begin_quote
  public <Име на клас>(<Име на клас> <име на променлива>){
       this.<атрибут> = <име на променлива>.<атрибут>;
       ...
  }
  #+end_quote

   #+begin_src csharp
   public Rational(Rationa r){
       this.num = r.num;
       this.den = r.den;
   }
   #+end_src

* Предаване на аргументи
** Референции
- За променливи от примитивен тип име и адрес на променливата е едно и също нещо.
  Когато използваме в оператор името на такава променлива компилаторът замества
  името на променливата със стойността намираща се на съпоставения адрес.
- При променливи, които са инстанции на клас от обекти, стойността им е адресът в
  паметта, където са разположени атрибутите на инстанцията.  Стойностите на
  такива променливи се наричат указатели/референции
** Предаване на прараметри по стойност
- Когато извикаме функция, която има аргумент от примитивен тип, стойността,
  с която сме я извикали се копира в нейния параметър. Това се нарича предаване
  по стойност. Ако променим стойността на параметъра вътре във функцията, тази
  промяна не се отразява на променливата, която е подадена като аргумент.
** Предаване на фактически параметри по референция
- Когато подаваме като аргумент променлива от тип референция, например инстанция
  на клас, то всички промени извършени в метода се запазват в инстанцията.
- Можем да подадем като аргумент и променливи от примитивен тип като референция.
  Това позволява на метода да променя стойността на тази пременлива.  За целта
  се използва ключовата дума "ref", която при дефинирането на метода се записва
  пред типа на формалния параметър.

* Агрегатни типове
** Структура от данни
- област от паметта, в която се разполагат множество от данни по определен
  начин.

** Агрегатни типове данни
- Структури от данни, съставени от елементи на един и същ тип. (масиви)

** Едномерен масив
- Структура от данни, съставена от полета с еднакъв размер, в които могат
  да се запазват група от стойности от един и същи тип

** Елементи на масива
- име_на_масива[индекс_на_елемента]
- първият елемент има индекс 0
- стр 90/фиг. 1

** Деклариране на едномерен масив и заделяне на памет
*** деклариране - <type>[] <arr_name>;
*** алокиране на памет - <arr_nmae> = new <type>[<arr_length>];
*** Example
#+begin_src csharp
int[] x = new int[10];
#+end_src

*** Инициализация / Задаване на начални стойности
*** Начини за инициализация на масив
**** В оператора за деклариране
#+begin_src csharp
int[] x = {5,13,12,45};
#+end_src
**** С присвояване в кода на програмата
#+begin_src csharp
x[0] = 4;
x[1] = 3;
x[2] = 5;
#+end_src
**** Въвеждане от потребителя
#+begin_src csharp
for(int i = 0; i < x.Length; i++){
    x[i] = int.Parse(Console.ReadLine());
}
#+end_src
*** Извеждане на елементите на едномерен масив
** Задача
- Създайте конзолно приложение, което декларира и заделя памет за едномерен
  масив с 10 цели числа. Да се въведат от клавиатурната стойности на елементите на масива.
  Да се изведат на екрана въведените от потребителя стойности на един ред.
** Статични агрегатни типове
- Не могат да променят размера си по време на изпълнение на програмата.
- Пример - масиви
** Динамични аграгатни типове
- Могат да променят размерите си по време на работа на програмата.
  Тези типове са оформени като класове, които се наричат колекции.
- Примери - стек, опашка, списък
** Списък
- Наредена последователност от еднотипни елементи, като размерът му може да се
  променя по време на работа на програмата.
** Основни методи за работа със списък
*** Clear()
- изтрива всички елементи от списъка
*** Add(el)
- добавя елемент в края на списъка
*** Insert(pos, el)
- вмъкване на el на оказаната от pos позиция
*** RemoveAt(pos)
- премахва елемент на оказаната от pos позиция
*** [i]
- дава достъп до елемент с посочения индекс
** Елемент списъчна кутия
- добавя се от тулбокс - ListBox
- служи за показване на последователности от елементи. Елементите на списъка се задават в
  свойство "Items".

* Файлове
** Потоци от данни
- подредени последователности от байтове.
** System.IO
- Пространство от имена, което трябва да се добави към програмата, когато работим с файлове.
** Физически файл
- Реалният файл разположен в файловата система.
** Логически файл
- Образът на физическия файл в програмата.
** Записване в такстов файл
- Write(), WriteLine()
*** създаване на логическит файл и свързване с физическия
#+begin_src csharp
StreamWriter <lofile> = new StreamWriter("<phfile>", doAppend, encoding);
StreamWriter sw = new StreamWriter("test.txt", true, Encoding.GetEncoding("Unicode"));
#+end_src
*** записване на данни във файла
#+begin_src csharp
sw.WriteLine("Some witty remark.");
#+end_src
*** затваряне на файла
#+begin_src csharp
sw.Close();
#+end_src

** Компонент многоредова текстова кутия / RichTextBox
- В този елемент можем да извеждаме текст на повече от един ред

** Четене от текстов файл
*** създаване на логически файл, който свързваме с физическия
#+begin_src csharp
StreamReader <lofile> = new StreamReader("<phfile>", <encoding>);
StreamReader r = new StreamReader("text.txt", Encoding.GetUncoding("Unicode"));
#+end_src

*** четене
#+begin_src csharp
string line = r.ReadLine(); // Четене на един ред
string rest = r.ReadToEnd(); // Четене на цял файл
#+end_src

*** затваряне на файла
#+begin_src csharp
r.Close();
#+end_src
* Класът string
- масиви от символи

** Свойства
+ Length - определя броя символи в низа.
** Методи на класът string
+ ToLower()
+ ToUpper()
+ IndexOf(searchString, startIndex) - Връща индекса на първия символ от
  низа за проверка ако го намери, в противен случай - -1;
+ LastIndexOf(searchString, startIndex) - Връща индекса на последния символ
  от низа за проверка ако го намери, в противен случай - -1;
+ SubString(startIndex, numOfChars)
+ Replace(s1, s2)

** Компонент комбинирана текстова кутия / ComboBox
- текстова кутия, съдъжанието на която се избира от списък с няколко възможни стойности
- стойностите за избор се задават в свойство Items

* Документиране на клас
** XML
XML - extended markup language
** Автоматизирано докуметиране на клас
+ <name></name>
+ /// - коментар
** Сериализация
- Процес, при който обект се конвертира до поток от байтове.
*** Начини за сериализиране на обекти
+ XML сериализиране - обект се превръща в XML поток.
+ двоично сериализиране - предпочитан метод, поради скоростта и компактността му.
*** При създаване на двоичен сериализиращ файл трябва да се включат следните пространства от имена
+ using System.IO;
+ using System.Runtime.Serialization;
+ using System.Runtime.Serialization.Formatters.Binary;
*** Ако искаме да сериализираме инстанциите на даден клас, трябва да поставим в началото на дефиницията му:
#+begin_src csharp
[Serializable()]
class MyClass {
    public MyClass(){}
}
#+end_src
*** Пример за сериализация
+ Включваме необходимите пространства от имена
+ Дефинираме си класа като преди дефиницията му записваме [Serializable()]
+ Създаваме обект от класа и записваме стойности в атрибутите му.
+ Създаваме инстанция на класа BinaryFormatter, с която трансформираме данните
  в двоичен вид
  #+begin_src csharp
IFormatter formatter = new BinaryFormatter();
  #+end_src
+ Отваряне на необходимия за сериализацията двоичен файл.
  #+begin_src csharp
Stream stream = new FileStream('file.bin', FileMode.Create, FileAccess.Write);
  #+end_src
+ Записване на данните във файл
  #+begin_src csharp
formatter.Serializ(stream, obj);
  #+end_src

** Десериализация
- Конвертиране на поток от байтове в обект.
*** Свързваме физическия файл с логическия.
#+begin_src csharp
Stream stream = new FileSream("serial.bin", FileMode.Open, FileAccess.Read);
#+end_src
*** Създаваме инстанция на класа BinaryFormatter за метода Serialize()
*** Десериализация
#+begin_src csharp
MyClass cls = (MyClass)formatter.Deserialize(stream);
#+end_src

** Сериализиране на масив от инстанции
- По същия начин, както за обект, но вместо името на обекта се записва името на
  масива.
  
* Капсулиране. Статични атрибути и методи
** Капсулиране
- скриване на някои от атрибутите и методите на класа от външен достъп

** Модификатори 
+ public
+ private
+ protected - до такива членове имат достъп само методите на същия клас и
  класовете, които го наследяват
+ internal - до тези членове имат достъп само методите на същия клас, но не
  и на класовете, които го наследяват

** Достъп до класовете и членовете на класа

** Статични членове на клас
+ атрибути на класа/статични атрибути
+ методи на класа/статични методи - тези методи имат достъп само до статичните
  методи на класа и други статични методи

** Константи
<модификатор> const <тип> <име> = <стойност>
* Йерархии от класове

** Наследяване
- класът наследник, ще има всички атрибути на класа родител
class <клас наследник> : <клас родител>

** Пренаписване на методи
+ ако искаме в класа наследник да променим действието на метод, наследен от
  базовия клас можем да декларираме метод със същата сигнатура и различно тяло.
+ базовият метод трябва да е деклариран с virtual
+ а производния - с override

** Модификаторът protected
- членовете на класа декларирани като protected не са достъпни извън класа, но
  са достъпни от методи на всеки производен клас.

** Класът object
- това е базовият клас в c# и всички са наследници на този клас

* Полиморфизъм
** Полиморфизъм
- имащ много форми
** Видове полиморфизъм
+ функция извършва различни действия в зависимост от това колко и какъв тип
  аргументи са подадени.
+ пренаписване на метод в клас наследник
** Преобразуване нагоре
- на инстанция от базов клас се присвоява инстанция от клас наследник
** Преобразуване надолу
- преобразуваме явно обект от базов клас в обект от производен клас
** Предефиниране на операциите
- за всяка операция, която искаме да предефинираме
