#+TITLE: CS Plans

* Съдържание :toc:
- [[#преговор][Преговор]]
  - [[#архитектура-на-съвременния-компютър---стр-4-фигура-1][Архитектура на съвременния компютър - стр 4 фигура 1]]
  - [[#хардуер-физическа-част][Хардуер (физическа част)]]
  - [[#софтуер][Софтуер]]
  - [[#функции-на-операционната-система][Функции на операционната система]]
- [[#езици-на-програмиране][Езици на програмиране]]
  - [[#машинен-език---01][Машинен език - 0/1]]
  - [[#асемблерен-език][Асемблерен език]]
  - [[#алгоритмичен-език][Алгоритмичен език]]
  - [[#синтаксис-и-семантика-на-език-за-програмиране][Синтаксис и семантика на език за програмиране]]
  - [[#обектно-ориентирано-програмиране][Обектно-ориентирано програмиране]]
- [[#инструменти-и-среди-за-програмиране][Инструменти и среди за програмиране]]
  - [[#програмни-проекти][Програмни проекти]]
  - [[#етапи-при-разработване-на-програмен-проект][Етапи при разработване на програмен проект]]
  - [[#инструменти-за-създаване-на-програми][Инструменти за създаване на програми]]
  - [[#среда-за-програмиране][Среда за програмиране]]
- [[#интегрирана-среда-за-програмиране-visual-studio][Интегрирана среда за програмиране Visual Studio]]
  - [[#проект-и-решение][Проект и решение]]
  - [[#стандартен-вход-и-изход][Стандартен вход и изход]]
- [[#елементи-на-програма-на-c][Елементи на програма на C#]]
  - [[#какво-представляват-програмите][Какво представляват програмите]]
  - [[#какво-представляват-думите][Какво представляват думите]]
  - [[#ключови-думи][Ключови думи]]
  - [[#имена-идентификатори-на-елементите-на-език-c][Имена (идентификатори) на елементите на език C#]]
  - [[#данни][Данни]]
  - [[#деклариране-на-променливи][Деклариране на променливи]]
  - [[#структура-на-програмата][Структура на програмата]]
  - [[#знаци][Знаци]]
  - [[#коментари][Коментари]]
  - [[#оформяне-на-програмата][Оформяне на програмата]]
- [[#основни-типове-операции-и-оператори][Основни типове операции и оператори]]
  - [[#видове-операции][Видове операции]]
  - [[#артиметични-операции-с-цели-числа][Артиметични операции с цели числа:]]
  - [[#аритметични-операции-с-дробни-числа][Аритметични операции с дробни числа:]]
  - [[#аритметичен-израз][Аритметичен израз]]
  - [[#операция-за-присвояване-][Операция за присвояване: =]]
- [[#изчислителни-процеси-линейни-процеси][Изчислителни процеси. Линейни процеси]]
  - [[#език-за-специфициране-uml][Език за специфициране UML]]
  - [[#uml-диаграма-на-изчислителен-процес][UML диаграма на изчислителен процес]]
  - [[#видове-изчислителни-процеси][Видове изчислителни процеси]]
  - [[#медоти-за-избягване-на-повторението-на-код][Медоти за избягване на повторението на код]]
  - [[#методът-parse][Методът Parse]]
  - [[#класът-math][Класът Math]]
  - [[#линейни-изчилистелни-процеси---упр][Линейни изчилистелни процеси - упр]]
- [[#сравнение-и-логически-операции][Сравнение и логически операции]]
  - [[#логически-стойности---boolean][Логически стойности - boolean]]
  - [[#операции-за-сравняване][Операции за сравняване]]
  - [[#логически-операции][Логически операции]]
  - [[#логически-изрази---сраница-48-фиг-4][Логически изрази - сраница 48 фиг. 4]]
- [[#разклонени-изчислителни-процеси][Разклонени изчислителни процеси]]
  - [[#условен-оператор---if][Условен оператор - if]]
  - [[#оператор-за-многовариантен-избор][Оператор за многовариантен избор]]
- [[#циклични-изчислителни-процеси][Циклични изчислителни процеси]]
- [[#обекти-и-класове-от-обекти][Обекти и класове от обекти]]
  - [[#обекти][Обекти]]
  - [[#класове-от-обекти][Класове от обекти]]
  - [[#инстанция-екземпляр-на-класа][Инстанция (Екземпляр) на класа]]
  - [[#атрибути-на-класа][Атрибути на класа]]
  - [[#методи-на-класа][Методи на класа]]
  - [[#пример-за-клас][Пример за клас]]
  - [[#изисквания-при-създаване-на-клас][Изисквания при създаване на клас]]
  - [[#uml-диаграма-на-клас---стр-56фиг-2][UML диаграма на клас - стр. 56/фиг. 2]]
  - [[#нива-на-абстракция][Нива на абстракция]]
- [[#класове][Класове]]
  - [[#дефиниране-на-клас-от-обекти][Дефиниране на клас от обекти]]
  - [[#създаване-на-обект-от-клас][Създаване на обект от клас]]
- [[#клас-с-контролирани-атрибути][Клас с контролирани атрибути]]
  - [[#дефиниране-на-клас-с-контролирани-атрибути][Дефиниране на клас с контролирани атрибути]]
  - [[#достъп-до-контролираните-атрибути][Достъп до контролираните атрибути]]
- [[#функции-и-методи][Функции и методи]]
  - [[#функции][Функции]]
  - [[#област-на-видимост-на-променливите][Област на видимост на променливите]]
  - [[#обектът-като-аргумент][Обектът като аргумент]]
- [[#конструктори][Конструктори]]
  - [[#конструктор-по-премълчаване][Конструктор по премълчаване]]
  - [[#конструктор-с-аргументи][Конструктор с аргументи]]
  - [[#конструктор-за-копиране][Конструктор за копиране]]
- [[#предаване-на-аргументи][Предаване на аргументи]]
  - [[#референции][Референции]]
  - [[#предаване-на-прараметри-по-стойност][Предаване на прараметри по стойност]]
  - [[#предаване-на-фактически-параметри-по-референция][Предаване на фактически параметри по референция]]
- [[#агрегатни-типове][Агрегатни типове]]
  - [[#структура-от-данни][Структура от данни]]
  - [[#агрегатни-типове-данни][Агрегатни типове данни]]
  - [[#едномерен-масив][Едномерен масив]]
  - [[#елементи-на-масива][Елементи на масива]]
  - [[#деклариране-на-едномерен-масив-и-заделяне-на-памет][Деклариране на едномерен масив и заделяне на памет]]
  - [[#задача][Задача]]
  - [[#статични-агрегатни-типове][Статични агрегатни типове]]
  - [[#динамични-аграгатни-типове][Динамични аграгатни типове]]
  - [[#списък][Списък]]
  - [[#основни-методи-за-работа-със-списък][Основни методи за работа със списък]]
  - [[#елемент-списъчна-кутия][Елемент списъчна кутия]]
- [[#файлове][Файлове]]
  - [[#потоци-от-данни][Потоци от данни]]
  - [[#systemio][System.IO]]
  - [[#физически-файл][Физически файл]]
  - [[#логически-файл][Логически файл]]
  - [[#записване-в-такстов-файл][Записване в такстов файл]]
  - [[#компонент-многоредова-текстова-кутия--richtextbox][Компонент многоредова текстова кутия / RichTextBox]]
  - [[#четене-от-текстов-файл][Четене от текстов файл]]
- [[#класът-string][Класът string]]
  - [[#свойства][Свойства]]
  - [[#методи-на-класът-string][Методи на класът string]]
  - [[#компонент-комбинирана-текстова-кутия--combobox][Компонент комбинирана текстова кутия / ComboBox]]
- [[#документиране-на-клас][Документиране на клас]]
  - [[#xml][XML]]
  - [[#автоматизирано-докуметиране-на-клас][Автоматизирано докуметиране на клас]]
  - [[#сериализация][Сериализация]]
  - [[#десериализация][Десериализация]]
  - [[#сериализиране-на-масив-от-инстанции][Сериализиране на масив от инстанции]]
- [[#капсулиране-статични-атрибути-и-методи][Капсулиране. Статични атрибути и методи]]
  - [[#капсулиране][Капсулиране]]
  - [[#модификатори][Модификатори]]
  - [[#достъп-до-класовете-и-членовете-на-класа][Достъп до класовете и членовете на класа]]
  - [[#статични-членове-на-клас][Статични членове на клас]]
  - [[#константи][Константи]]
- [[#йерархии-от-класове][Йерархии от класове]]
  - [[#наследяване][Наследяване]]
  - [[#пренаписване-на-методи][Пренаписване на методи]]
  - [[#модификаторът-protected][Модификаторът protected]]
  - [[#класът-object][Класът object]]
- [[#полиморфизъм][Полиморфизъм]]
  - [[#полиморфизъм-1][Полиморфизъм]]
  - [[#видове-полиморфизъм][Видове полиморфизъм]]
  - [[#преобразуване-нагоре][Преобразуване нагоре]]
  - [[#преобразуване-надолу][Преобразуване надолу]]
  - [[#предефиниране-на-операциите][Предефиниране на операциите]]
- [[#абстрактни-класове][Абстрактни класове]]
  - [[#абстрактен-клас][Абстрактен клас]]
  - [[#абстрактни-методи][Абстрактни методи]]
  - [[#интерфейси][Интерфейси]]
  - [[#явна-и-неявна-реализация-на-интерфейс][Явна и неявна реализация на интерфейс]]
- [[#изключения][Изключения]]
  - [[#xвърляне-и-прихващане-на-изключения][Xвърляне и прихващане на изключения]]
  - [[#предефиниране-на-изключения][Предефиниране на изключения]]
  - [[#потребителски-изключения][Потребителски изключения]]
- [[#алгоритми][Алгоритми]]
  - [[#алгоритъм][Алгоритъм]]
  - [[#основни-характеристи-на-алгоритмите][Основни характеристи на алгоритмите]]
  - [[#начини-за-представяне-на-алгоритми][Начини за представяне на алгоритми]]
  - [[#видове-алгоритми][Видове алгоритми]]
- [[#упражнения-ву-uml-диаграми][Упражнения в/у UML диаграми]]
- [[#сложност-на-алгоритми][Сложност на алгоритми]]
  - [[#размер-на-входа][Размер на входа]]
  - [[#сложност-на-алгортъм][Сложност на алгортъм]]
  - [[#функции-на-сложност][Функции на сложност]]
- [[#обектно-ориентирано-програмиране---преговор][Обектно-ориентирано програмиране - преговор]]
  - [[#обекти-и-класове-от-обекти-1][Обекти и класове от обекти]]
  - [[#атрибути-и-методи][Атрибути и методи]]
  - [[#капсулиране---стр-14][Капсулиране - стр. 14]]
  - [[#наследяване-1][Наследяване]]
- [[#реализация-на-алгоритми-чрез-методи][Реализация на алгоритми чрез методи]]
  - [[#предефиниране-на-метод---стр-18][Предефиниране на метод - стр. 18]]
  - [[#претоварване-на-метод][Претоварване на метод]]
- [[#рекурсия-и-итерация][Рекурсия и итерация]]
  - [[#същност-на-рекурсията][Същност на рекурсията]]
  - [[#рекурсия-в-c][Рекурсия в c#]]
  - [[#видове-рекурсия][Видове рекурсия]]
  - [[#дъно-на-рекурсия][Дъно на рекурсия]]
  - [[#примери-за-рекурсия][Примери за рекурсия]]
  - [[#прав-и-обратен-ход-на-рекурсията][Прав и обратен ход на рекурсията]]
- [[#упражнения-върху-рекурсия][Упражнения върху рекурсия]]
  - [[#нод][НОД]]
  - [[#сума][Сума]]
  - [[#факториел][Факториел]]
  - [[#фибоначи][Фибоначи]]
  - [[#брой-на-цифри][Брой на цифри]]
  - [[#сума-на-цифри-на-число][Сума на цифри на число]]
- [[#сложност-на-програми][Сложност на програми]]
  - [[#сложност-на-програма-на-c][Сложност на програма на C#]]
  - [[#сложност-на-рекурсивни-програми][Сложност на рекурсивни програми]]
  - [[#решаване-на-рекурентни-зависимости][Решаване на рекурентни зависимости]]
  - [[#логаритмични-функции][Логаритмични функции]]
- [[#едномерен-масив---преговор][Едномерен масив - преговор]]
  - [[#същност][Същност]]
  - [[#деклариране-на-едномерен-масив][Деклариране на едномерен масив]]
  - [[#инициализиране][Инициализиране]]
  - [[#размер-и-преоразмеряване-на-масив][Размер и преоразмеряване на масив]]
  -  [[#стр-31зад-1][Стр 31/зад. 1]]
- [[#сортиране-на-масив][Сортиране на масив]]
  - [[#дефиниция][Дефиниция]]
  - [[#класически-алгоритми-за-сориране][Класически алгоритми за сориране]]
- [[#работа-със-сортирани-масиви][Работа със сортирани масиви]]
  - [[#търсене-в-масив][Търсене в масив]]
  - [[#двоично-търсене-в-сортиран-масив][Двоично търсене в сортиран масив]]
- [[#сливане-на-сортирани-масиви][Сливане на сортирани масиви]]
- [[#низове][Низове]]
  - [[#операции-с-низове][Операции с низове]]
  - [[#клас-stringbuilder][Клас Stringbuilder]]
- [[#масиви-от-знаци][Масиви от знаци]]
  - [[#клас-chararray][Клас CharArray]]
  - [[#методи][Методи]]
- [[#многомерени-масиви][Многомерени масиви]]
  - [[#двумерен-масив][Двумерен масив]]
  - [[#деклариране-на-двумерен-масив-и-заделяне-на-памет][Деклариране на двумерен масив и заделяне на памет]]
  - [[#инициализация-на-двумерен-масив][Инициализация на двумерен масив]]
  - [[#обхождане-на-двумерен-масив][Обхождане на двумерен масив]]
  - [[#извеждане-на-двумерен-масив][Извеждане на двумерен масив]]
- [[#абстрактни-типове-данни][Абстрактни типове данни]]
  - [[#какво-е-абстрактен-тип][Какво е абстрактен тип]]
  - [[#дефиниране-на-абстрактен-тип][дефиниране на абстрактен тип]]
  - [[#реализация-на-абстрактен-тип][Реализация на абстрактен тип]]
  - [[#програмиране-с-абстрактни-типове-данни][Програмиране с абстрактни типове данни]]
- [[#вградени-абстрактни-типове-в-c][Вградени абстрактни типове в c#]]
  - [[#колекции][Колекции]]
  - [[#видове-колекции][Видове колекции]]
  - [[#пространство-от-имена][Пространство от имена]]
  - [[#елементи-на-колекция][Елементи на колекция]]
  - [[#колекция-arraylist][Колекция ArrayList]]
- [[#списъци][Списъци]]
  - [[#колекция-list][Колекция List]]
  - [[#колекция-sortedlist][Колекция SortedList]]
- [[#опашка][Опашка]]
  - [[#дефиниция-1][Дефиниция]]
  - [[#статична-реализация][Статична реализация]]
  - [[#вграден-клас-queueт][Вграден клас Queue<Т>]]
- [[#стек][Стек]]
  - [[#дефиниция-2][Дефиниция]]
  - [[#статична-реализаци][Статична реализаци]]
  - [[#вграден-клас-stackt][Вграден клас Stack<T>]]
- [[#множества][Множества]]
  - [[#понятието-множество][Понятието множество]]
  - [[#симбовли][Симбовли]]
  - [[#визуализация-на-множество][Визуализация на множество]]
  - [[#характеристика][Характеристика]]
  - [[#операции][Операции]]
  - [[#представяне][Представяне]]

* Преговор
** Архитектура на съвременния компютър - стр 4 фигура 1
+ комуникационна шина
+ централен процесор
+ оперативна памет (RAM)

** Хардуер (физическа част)
+ Централен процесор
  - електронно устройство, способно да изпълнява множество команди за работа
    с данни

+ Оперативна памет
  - съхранява изпълняваната програма и данните, необходими за нейното
    изпълнени

+ Твърд диск

+ Входно-изходни устройства

+ Контролери
  - специализирани процесори, които управляват входно-изходните усройства (звукова
    карта, видео карта, мрежова карта и др.)

** Софтуер
+ Системен софтуер - операционна система
+ Приложен софтуер

** Функции на операционната система
+ усъществяване на диалог с потребителя
  - Основното предназначение на ОС е да създаде на потребителя условия за
    работа. Това става чрез специализирани езици, наричани интерфейси.
    Съвремениите ОС предлагат два вида интерфейси - графичен и команден
    (буквенно-цифров).

+ управление на изпълнението на програми

+ управление на входно-изходните устройства

* Езици на програмиране
** Машинен език - 0/1

** Асемблерен език
- Асемблер - програма, която превежда от асемблерен на машинен език

** Алгоритмичен език
+ Транслатор - програма, която превежда от алгоритмичен на машинен език. Биват два вида:
  - Компилатор
  - Интерпретатор

** Синтаксис и семантика на език за програмиране
+ Синтаксис
  - правилата, по които задължително трябва да се изписват конструкциите на
    езика за програмиране

+ Семантика
  - смисълът, който се влага във всяка от конструкциите

** Обектно-ориентирано програмиране
- Създават се класове на еднотипни обекти от реалнотта, в които са вкючени
  описващите ги данни и методи за обичайните операции

* Инструменти и среди за програмиране
** Програмни проекти
- Проект наричаме всяко множество от дейности, което има точно определена цел
и трябва да доведе до получаване на очаквани резултати в рамките на определно
време и ресурси.

** Етапи при разработване на програмен проект
+ Анализ на задачата
+ Проектиране
+ Разработване - създаване на графичен дизаин, писане на код и цялостно
  изграждане на проекта
+ Документиране

** Инструменти за създаване на програми
+ Текстов редактор
+ Редактор за графичен интерфейс
+ Транслатор
+ Дебъгер
+ Други инструменти

** Среда за програмиране
- съвкупността от инструментални програми предназначени за създаване на
  нови програми
- Съвремената тенденция е да се интегрират всички елементи на системата за
  програмиране в едно цяло, наричано интегрирана среда за програмиране

* Интегрирана среда за програмиране Visual Studio
** Проект и решение
** Стандартен вход и изход

* Елементи на програма на C#
** Какво представляват програмите
- Текстове съставени от знаците на клавиатурната азбука

** Какво представляват думите
- Последователност от знаци които представляват съответните синтактични
  категории на езика

** Ключови думи
- Имат строго определено предназначение в езика, което не може да се променя
- страница 21, таблица

** Имена (идентификатори) на елементите на език C#
- Имената в C# са думи съставени от латински букви, цифри и знака за подчертаване,
започващи с латинска буква. За имена не могат да се използват ключови думи.

** Данни
+ константи (const) - полета от паметта, чието съдържание не се мени по
  време на програмта
+ поменливи (variable) - полета от паметта, чието съдържание се мени по
  време на програмата
+ литерали (literals) - константи, които се използват пряко в кода на
  програмата без да им се дават имена
#+begin_src csharp
int a = 1;
string b = "cat";
#+end_src
1 и "cat" са литерали.

** Деклариране на променливи
<тип> <име на променлива>

** Структура на програмата

** Знаци

** Коментари
+ коментар на един ред - //
+ коментар на няколко реда - /* */

** Оформяне на програмата

* Основни типове операции и оператори
** Видове операции
+ унарни
+ бинарни
+ други
** Артиметични операции с цели числа:
+ +
+ -
+ *
+ %
** Аритметични операции с дробни числа:
+ +
+ -
+ *
+ /
+ %
** Аритметичен израз
** Операция за присвояване: =
* Изчислителни процеси. Линейни процеси
** Език за специфициране UML
- Графичен език за специфициране и документиране на компонентите на софтуерна система
- Елементът на UML, в който се извършва всяко моделиране е диаграма
** UML диаграма на изчислителен процес
** Видове изчислителни процеси
+ линейни
+ разклонени
+ циклични
** Медоти за избягване на повторението на код
+ цикли
+ методи
** Методът Parse
** Класът Math
- съдържа методи за пресмятане на математически функции
** Линейни изчилистелни процеси - упр
Зад. Начертайте UML диаграма, която по зададени 2 числа изчилява и извежда периметърат и лицето на правоъгълник с тези параметри

* Сравнение и логически операции
** Логически стойности - boolean
** Операции за сравняване
+ ==
+ >
+ <
+ >=
+ <=
+ !=
** Логически операции
+ && (логическо и / логическо умножение)
+ || (логическо или / логическо събиране)
+ !
** Логически изрази - сраница 48 фиг. 4

* Разклонени изчислителни процеси
** Условен оператор - if
#+begin_src csharp
if(<condition>)
{
    <code>
}
else
{
    <code>
}
#+end_src

** Оператор за многовариантен избор
#+begin_src csharp
switch(<variable>){
case <case>:
    <code>;
    break;
}
#+end_src

* Циклични изчислителни процеси
+ Операции за цикъл с параметър
+ Оператор за цикъл с предусловие
+ Оператор за цикъл с постусловие
* Обекти и класове от обекти
** Обекти
В ООП се създават компютърни модели на реални или абстрактни обекти.
За всеки компютърен модел се добавят определени характеристики на обектите
и методи, чрез които се обработват обектите.
#+begin_src csharp
class Person {
}
#+end_src

** Класове от обекти
- всички еднотипни обекти с еднакви атрибути и методи.
** Инстанция (Екземпляр) на класа
- всеки конкретен обект от реалността със специфични стойности на атрибутите.
** Атрибути на класа
- това са характеристиките на обектите от класа и се наритат член-променливи
  на класа.
** Методи на класа
- функции извършващи необходимите обработки на обектите от класа. Наричат
  се още член-функции на класа.
** Пример за клас
+ клас човек (реален обект)
+ клас дроб, точка (абстрактен обект)
** Изисквания при създаване на клас
+ достатъчност - само необходимите/използвани характеристики
+ пълнота - всички необходими за задачата характеристики
+ простота - да се разбира, максимално опростен
** UML диаграма на клас - стр. 56/фиг. 2
** Нива на абстракция

* Класове
** Дефиниране на клас от обекти
!NB Дефинира се извън клас Program
#+begin_quote
public class <Име на клас> {
    [public/private] <тип> <име на атрибут>;
    [public/private] <тип за връщане> <име на метод>([<тип> <име на параметър>])
    {
        <код>
    }
}
#+end_quote

#+begin_src csharp
public class Person {
    public string name;
    public int age;
    public bool isMale;
}
#+end_src

** Създаване на обект от клас
#+begin_quote
<клас> <име на обект> = new <клас>();
#+end_quote

#+begin_src csharp
Person p1 = new Person();
p1.name = "Jiaqi";
p1.age = 17;
p1.isMale = true;
#+end_src

* Клас с контролирани атрибути
** Дефиниране на клас с контролирани атрибути
Използва се, когато програмистът не иска програмите, които използват класа да
имат пряк достъп до атрибутите му. Атрибутите на класа трябва да се дефинират
като private
** Достъп до контролираните атрибути
+ Създаване на setter
  - необходимо е, за да можем да записваме стойност в контролираните атрибути
+ Синтаксис на конструкцията за създаване на setter
#+begin_comment
public <type> <public name>
{
    set { this.<private name> = value }
}
#+end_comment

#+begin_src csharp
public string Brand {
    set { this.brand = value; }
}
#+end_src

+ Създаване на getter
  - необходимо е, за да можем достъпваме записаните стойности в контролираните
    атрибути
+ Синтаксис на конструкцията за създаване на getter
#+begin_comment
public <type> <public name>
{
    get { return this.<private name> }
}
#+end_comment
#+begin_src csharp
public string Brand {
    get { return this.brand; }
}
#+end_src

+ Създаване на setter и getter
#+begin_src csharp
public string Brand {
    set { this.brand = value; }
    get { return this.brand; }
}
#+end_src

* Функции и методи
** Функции
- създават се, когато се налага част от програмният код да се използва многократно
+ синтаксис за създаване на функция
#+begin_quote
<модификатор> <тип на резултат> <Име на метод>([<тип> <име на параметър>, <тип> <име на 2ри параметър>])
{
    ...
    return ...;
}
#+end_quote

#+begin_src csharp
public double SquareArea(double a)
{
    return a*a;
}
double s = SquareArea(4); // s = 16;
#+end_src

+ видове функции:
  - с параметри и без параметри
  - които връщат стойност и които не връщат стойност
+ претоварване на имената (method overloading)
  - можем да именуваме по един и същи начин две различни по съдържание функции,
    които имат различна сигнатура
+ сигнатура на функция
  - уникалната комбинация от типове и имена на параметерите.
+ полиморфизъм
  - еднакво именувани функциии звършват различни неща
** Област на видимост на променливите
+ глобални
+ локални
** Обектът като аргумент

* Конструктори
** Конструктор по премълчаване
- Метод за създаване на инстанция на даден клас. Той се създава по подразбиране
  при дефинирането на класа. Занулява всички атрибути на класа.
- Вид на конструктор: <Клас>();
  #+begin_src csharp
  Car myCar = new Car();
  #+end_src
- Предифиниране на стандартния конструктор
  #+begin_src csharp
  public Car() {

      this.model = "Model X";
      this.year = 2020;
      this.engineVolume = 500;
  }
  #+end_src

** Конструктор с аргументи
- Специален метод за създаване на инстанция на даден клас, задаваща начални
  стойности на атрибутите на тоя обект.

** Конструктор за копиране
- конструктор, чиято цел е да присвои стойностите на атрибута от един обект
  на друг
- дефиниране на копиращ конструктор
  #+begin_quote
  public <Име на клас>(<Име на клас> <име на променлива>){
       this.<атрибут> = <име на променлива>.<атрибут>;
       ...
  }
  #+end_quote

   #+begin_src csharp
   public Rational(Rationa r){
       this.num = r.num;
       this.den = r.den;
   }
   #+end_src

* Предаване на аргументи
** Референции
- За променливи от примитивен тип име и адрес на променливата е едно и също нещо.
  Когато използваме в оператор името на такава променлива компилаторът замества
  името на променливата със стойността намираща се на съпоставения адрес.
- При променливи, които са инстанции на клас от обекти, стойността им е адресът в
  паметта, където са разположени атрибутите на инстанцията.  Стойностите на
  такива променливи се наричат указатели/референции
** Предаване на прараметри по стойност
- Когато извикаме функция, която има аргумент от примитивен тип, стойността,
  с която сме я извикали се копира в нейния параметър. Това се нарича предаване
  по стойност. Ако променим стойността на параметъра вътре във функцията, тази
  промяна не се отразява на променливата, която е подадена като аргумент.
** Предаване на фактически параметри по референция
- Когато подаваме като аргумент променлива от тип референция, например инстанция
  на клас, то всички промени извършени в метода се запазват в инстанцията.
- Можем да подадем като аргумент и променливи от примитивен тип като референция.
  Това позволява на метода да променя стойността на тази пременлива.  За целта
  се използва ключовата дума "ref", която при дефинирането на метода се записва
  пред типа на формалния параметър.

* Агрегатни типове
** Структура от данни
- област от паметта, в която се разполагат множество от данни по определен
  начин.

** Агрегатни типове данни
- Структури от данни, съставени от елементи на един и същ тип. (масиви)

** Едномерен масив
- Структура от данни, съставена от полета с еднакъв размер, в които могат
  да се запазват група от стойности от един и същи тип

** Елементи на масива
- име_на_масива[индекс_на_елемента]
- първият елемент има индекс 0
- стр 90/фиг. 1

** Деклариране на едномерен масив и заделяне на памет
- деклариране - <type>[] <arr_name>;
- алокиране на памет - <arr_nmae> = new <type>[<arr_length>];
- Example
#+begin_src csharp
int[] x = new int[10];
#+end_src

- Инициализация / Задаване на начални стойности
- Начини за инициализация на масив
+ В оператора за деклариране
#+begin_src csharp
int[] x = {5,13,12,45};
#+end_src
+ С присвояване в кода на програмата
#+begin_src csharp
x[0] = 4;
x[1] = 3;
x[2] = 5;
#+end_src
+ Въвеждане от потребителя
#+begin_src csharp
for(int i = 0; i < x.Length; i++){
    x[i] = int.Parse(Console.ReadLine());
}
#+end_src
+ Извеждане на елементите на едномерен масив
** Задача
- Създайте конзолно приложение, което декларира и заделя памет за едномерен
  масив с 10 цели числа. Да се въведат от клавиатурната стойности на елементите на масива.
  Да се изведат на екрана въведените от потребителя стойности на един ред.
** Статични агрегатни типове
- Не могат да променят размера си по време на изпълнение на програмата.
- Пример - масиви
** Динамични аграгатни типове
- Могат да променят размерите си по време на работа на програмата.
  Тези типове са оформени като класове, които се наричат колекции.
- Примери - стек, опашка, списък
** Списък
- Наредена последователност от еднотипни елементи, като размерът му може да се
  променя по време на работа на програмата.
** Основни методи за работа със списък
+ Clear() - изтрива всички елементи от списъка
+ Add(el) - добавя елемент в края на списъка
+ Insert(pos, el) - вмъкване на el на оказаната от pos позиция
+ RemoveAt(pos) - премахва елемент на оказаната от pos позиция
+ [i] - дава достъп до елемент с посочения индекс
** Елемент списъчна кутия
- добавя се от тулбокс - ListBox
- служи за показване на последователности от елементи. Елементите на списъка се задават в
  свойство "Items".

* Файлове
** Потоци от данни
- подредени последователности от байтове.
** System.IO
- Пространство от имена, което трябва да се добави към програмата, когато работим с файлове.
** Физически файл
- Реалният файл разположен в файловата система.
** Логически файл
- Образът на физическия файл в програмата.
** Записване в такстов файл
- Write(), WriteLine()
+ създаване на логическит файл и свързване с физическия
#+begin_src csharp
StreamWriter <lofile> = new StreamWriter("<phfile>", doAppend, encoding);
StreamWriter sw = new StreamWriter("test.txt", true, Encoding.GetEncoding("Unicode"));
#+end_src
+ записване на данни във файла
#+begin_src csharp
sw.WriteLine("Some witty remark.");
#+end_src
+ затваряне на файла
#+begin_src csharp
sw.Close();
#+end_src

** Компонент многоредова текстова кутия / RichTextBox
- В този елемент можем да извеждаме текст на повече от един ред

** Четене от текстов файл
+ създаване на логически файл, който свързваме с физическия
#+begin_src csharp
StreamReader <lofile> = new StreamReader("<phfile>", <encoding>);
StreamReader r = new StreamReader("text.txt", Encoding.GetUncoding("Unicode"));
#+end_src

+ четене
#+begin_src csharp
string line = r.ReadLine(); // Четене на един ред
string rest = r.ReadToEnd(); // Четене на цял файл
#+end_src

+ затваряне на файла
#+begin_src csharp
r.Close();
#+end_src
* Класът string
- масиви от символи

** Свойства
+ Length - определя броя символи в низа.
** Методи на класът string
+ ToLower()
+ ToUpper()
+ IndexOf(searchString, startIndex) - Връща индекса на първия символ от
  низа за проверка ако го намери, в противен случай - -1;
+ LastIndexOf(searchString, startIndex) - Връща индекса на последния символ
  от низа за проверка ако го намери, в противен случай - -1;
+ SubString(startIndex, numOfChars)
+ Replace(s1, s2)

** Компонент комбинирана текстова кутия / ComboBox
- текстова кутия, съдъжанието на която се избира от списък с няколко възможни стойности
- стойностите за избор се задават в свойство Items

* Документиране на клас
** XML
XML - extended markup language
** Автоматизирано докуметиране на клас
+ <name></name>
+ /// - коментар
** Сериализация
- Процес, при който обект се конвертира до поток от байтове.
+ Начини за сериализиране на обекти
  - XML сериализиране - обект се превръща в XML поток.
  - двоично сериализиране - предпочитан метод, поради скоростта и компактността му.
+ При създаване на двоичен сериализиращ файл трябва да се включат следните пространства от имена
  - using System.IO;
  - using System.Runtime.Serialization;
  - using System.Runtime.Serialization.Formatters.Binary;
+ Ако искаме да сериализираме инстанциите на даден клас, трябва да поставим в началото на дефиницията му:
#+begin_src csharp
[Serializable()]
class MyClass {
    public MyClass(){}
}
#+end_src
+ Пример за сериализация
  - Включваме необходимите пространства от имена
  - Дефинираме си класа като преди дефиницията му записваме [Serializable()]
  - Създаваме обект от класа и записваме стойности в атрибутите му.
  - Създаваме инстанция на класа BinaryFormatter, с която трансформираме данните
    в двоичен вид
#+begin_src csharp
IFormatter formatter = new BinaryFormatter();
#+end_src
+ Отваряне на необходимия за сериализацията двоичен файл.
#+begin_src csharp
Stream stream = new FileStream('file.bin', FileMode.Create, FileAccess.Write);
#+end_src
+ Записване на данните във файл
#+begin_src csharp
formatter.Serializ(stream, obj);
#+end_src

** Десериализация
- Конвертиране на поток от байтове в обект.
+ Свързваме физическия файл с логическия.
#+begin_src csharp
Stream stream = new FileSream("serial.bin", FileMode.Open, FileAccess.Read);
#+end_src
+ Създаваме инстанция на класа BinaryFormatter за метода Serialize()
+ Десериализация
#+begin_src csharp
MyClass cls = (MyClass)formatter.Deserialize(stream);
#+end_src

** Сериализиране на масив от инстанции
- По същия начин, както за обект, но вместо името на обекта се записва името на
  масива.
  
* Капсулиране. Статични атрибути и методи
** Капсулиране
- скриване на някои от атрибутите и методите на класа от външен достъп

** Модификатори 
+ public
+ private
+ protected - до такива членове имат достъп само методите на същия клас и
  класовете, които го наследяват
+ internal - до тези членове имат достъп само методите на същия клас, но не
  и на класовете, които го наследяват

** Достъп до класовете и членовете на класа

** Статични членове на клас
+ атрибути на класа/статични атрибути
+ методи на класа/статични методи - тези методи имат достъп само до статичните
  методи на класа и други статични методи

** Константи
<модификатор> const <тип> <име> = <стойност>
* Йерархии от класове

** Наследяване
- класът наследник, ще има всички атрибути на класа родител
class <клас наследник> : <клас родител>

** Пренаписване на методи
+ ако искаме в класа наследник да променим действието на метод, наследен от
  базовия клас можем да декларираме метод със същата сигнатура и различно тяло.
+ базовият метод трябва да е деклариран с virtual
+ а производния - с override

** Модификаторът protected
- членовете на класа декларирани като protected не са достъпни извън класа, но
  са достъпни от методи на всеки производен клас.

** Класът object
- това е базовият клас в c# и всички са наследници на този клас

* Полиморфизъм
** Полиморфизъм
- имащ много форми
** Видове полиморфизъм
+ функция извършва различни действия в зависимост от това колко и какъв тип
  аргументи са подадени.
+ пренаписване на метод в клас наследник
** Преобразуване нагоре
- на инстанция от базов клас се присвоява инстанция от клас наследник
** Преобразуване надолу
- преобразуваме явно обект от базов клас в обект от производен клас
** Предефиниране на операциите
- за всяка операция, която искаме да предефинираме

* Абстрактни класове
** Абстрактен клас
- който има недовършена или липсваща реализация. Не можем да създаваме обекти от
  абстрактен клас можем да създаваме само негови класове наследници

** Абстрактни методи
- нереализирани методи. Абстрактните методи и класове се дефинират с ключовата
  дума abstract

** Интерфейси
- определят какви методи трябва да има един обект
- декларирането на интерфейс е както дефинирането на клас, но вместо КД клас се
  записва interface. Традиция е имената на интерфейсите да започват с главната
  буква I
- когато декларираме клас, който реализира даден интерфейс, след името на класа
  пишем ": <име на интерфей>". Ако са няколко интерфейса, разделяме ги със
  запетайка.

** Явна и неявна реализация на интерфейс
+ неявна
  - когато един клас реализира само един интерфейс, при създаване на методите от
    него не оказваме интерфейса.
+ явна
  - ако един клас реализира повече от един интерфейс и в тях има методи с еднаква
    сигнатура, при създаване на методите трябва да се окаже точно койк интерфейс
    реализираме. Това става като пред името на метода напишем <Име на
    Интерфейса>.<Име на метод>

* Изключения
** Xвърляне и прихващане на изключения
#+begin_src csharp
try
{
    <code>
}
catch(<Exception type> <var name>)
{
    <code>
}
catch(<Exception type> <var name>)
{
    <code>
}
#+end_src

** Предефиниране на изключения

** Потребителски изключения
- дефинират се от потребителя като наследници на класа Exception

* Алгоритми
** Алгоритъм
- последователност от действия, които водят до решение на дадена задача.
** Основни характеристи на алгоритмите
- резултатност - след изпълнение на стъпките да води до краен резултат.
- крайност - да приключва след краен брой стъпки.
- масовост - да решава група от еднотипни задачи.
- детерминираност - при едни и същи входни данни да се получава един и същ резултат.
- др.
** Начини за представяне на алгоритми
+ словесно
+ графично - блок схема/UML диаграма
+ с програмен код
** Видове алгоритми
+ линейни
+ разклонени
+ циклични

* Упражнения в/у UML диаграми
- стр. 7 / 1,2

* Сложност на алгоритми
** Размер на входа
- важен е за дефиниране на сложност на алгоритъма.
** Сложност на алгортъм
- разглеждат се два ресурса - време и памет
** Функции на сложност
+ линейна ф-ция (линейни алгоритми) - най-малка
+ при циклични алгоритми сложността се увеличава

* Обектно-ориентирано програмиране - преговор
** Обекти и класове от обекти
- ООП
- Клас от обекти
- Капсулиране
- Инстанция на клас

** Атрибути и методи
+ атрибути - характеристики на обектите
+ методи - действия, които могат да извършват обектите
** Капсулиране - стр. 14
** Наследяване

* Реализация на алгоритми чрез методи
** Предефиниране на метод - стр. 18
#+begin_src csharp
class Rectangle
{
    protected int a,b;
    public Rectangle(int a, int b)
    {
        ...
    }
    public Rectangle(int a){
        this.a = a;
    }
    public virtual double Area()
    {
        return a*b;
    }
}
class Square : Rectangle
{
    public Square(int a) : base(a){}
    public override double Area()
    {
        return a*a;
    }
}
#+end_src

- клас родител - public virtual <type> <Name>()
- клас наследник - public override <type> <Name>()
** Претоварване на метод
- методи с едно и също име, но различни параметри и тяло
- стр. 19

* Рекурсия и итерация
** Същност на рекурсията
+ рекурсивен обект - обект, който се съдържа в себе си или е дефиниран чрез себе си
  - числата на Фибоначи
  - снимка, в която се съдърфжа същата снимка
+ произход на думата рекурсия - лат. recursus - връщане

** Рекурсия в c#
+ средство за рекурсивно изразяване в С# - функции/методи
+ рекурсивни функции - функцията извиква сама себе си
+ рекурсивна програма - програма с поне една рекурсивна функция

** Видове рекурсия
+ пряка рекурсия - извъръшва обръщение към себе си
+ косвена рекурсия - непряко извиква себе си, чрез други функции, които извикат
  функцията.

** Дъно на рекурсия
- един или няколко случаи, чието решение можем да намерим директно бе рекурсивно извикване

** Примери за рекурсия
+ рекурсивно изчисляване на факаториел - n! = n*(n-1)!
+ числата на фибоначи -

** Прав и обратен ход на рекурсията
+ прав ход (разгъване на рекурсията) - всички действия, които се извършват до
  стигане на дъното на рекурсията.
+ обратен ход (свиване на рекурсията) - всички действия, които се извършват след
  стигане на дъното на рекурсията.

* Упражнения върху рекурсия
** НОД
#+begin_src csharp
static int GCD(int a, int b)
    => b == 0 ? a : GCD(b, a % b);
#+end_src
** Сума
#+begin_src csharp
static int Sum(int n)
    => n == 0 ? 0 : (n + sum(n-1));
#+end_src
** Факториел
#+begin_src csharp
static int Factorial(int n)
    => n == 0 ? 1 : (n * Factorial(n - 1));
#+end_src
** Фибоначи
#+begin_src csharp
static int Fibonachi(int n)
    => n == 1 || n == 2 ? 1 : (Fibonachi(n - 1) + Fibonachi(n - 2));
#+end_src
** Брой на цифри
#+begin_src csharp
static int Digits(int n)
    => n / 10 == 0 ? 1 : (1 + Digits(n / 10));
#+end_src
** Сума на цифри на число
#+begin_src csharp

#+end_src

* Сложност на програми
** Сложност на програма на C#
+ ще оценяваме сложността на алгоритмите по време
+ всеки израз ще го броим за константен брой операции
+ при оценка на условен оператор приемаме, че в най-лошия случай условието е
  изпълнено и тялото на оператора ще се изпълни. Затова за сложност на условния
  оператор ще броим сложността на условието + сложността на тялото на оператора.
  Тъй като в условния оператор има два възможни блока от оператори сложността му
  в най-лошия случай ще бъде равна на сложността на условието + сложността на
  по-сложният от двата блока
+ за пресмятане на сложността на оператора "for" трябва да се определи колко
  пъти ще се изпълни тялото на оператора.
+ циклите с предусловие и постусловие се оценяват както цикъла "for", но при тях
  по-трудно се определят броят на изпълненията.
+ за да оценим сложността на алгоритъм представен с нерекурсивна програма трябва
  да оценим сложността на всеки от операторите и да съберем получените сложности.

** Сложност на рекурсивни програми
- търсената сложност се появава в оценяващия израз.

** Решаване на рекурентни зависимости
- за да намерим сложността на рекурсивна фунцкия трябва да намерим сложността на
  съответната рекурентна зависимост

** Логаритмични функции

* Едномерен масив - преговор
** Същност
- поредни байтове от паметта, в които могат да се записват еднотипни данни.
** Деклариране на едномерен масив
#+begin_src csharp
int[] <name>;
#+end_src
** Инициализиране
#+begin_src csharp
int[] <name> = {n, n1, n2,...};
for(int i = 0; i < <name>.Length; i++)...
#+end_src
** Размер и преоразмеряване на масив
+ прави се копия на стария масив с метода arr.CopyTo(). След това променяме
  размера на стария масив.
  Направеното копие се пръща отново в стария масив.
#+begin_src csharp
int[] newArray;
oldArray.CopyTo(newArray, index);
oldArray = new int[newCount];
newArray.CopyTo(oldArray, index);
#+end_src
+ има готов статичен метод за директно преоразмеряване на масива
#+begin_src csharp
int[] arr;
int number;
Array.Resize(ref arr, number);
#+end_src

**  Стр 31/зад. 1

* Сортиране на масив
** Дефиниция
- подреждане на елементите на масив в определен ред. Ако ги подреждаме по
  големина, има два начина за сортиране - в намаляващ и нарастващ ред.
** Класически алгоритми за сориране
+ алгоритъм на мехурчето
  - за масив с n елемента се извършават n-1 обхождания на масива. Последователно
    всеки елемент се сравнява със следващия след него. Ако следващият елемент е
    по-малък от предходния те се разменят.
    1. обхождаме масива от а[0] до а[n-1].
    2. обхождаме масива от а[0] до а[n-2].
    3. обхождаме масива от а[0] до а[n-3].
    4. обхождаме масива от а[0] до а[n-4].
    Това е сортиране във възходящ ред.
+ пряка селекция
  - Ще обясни алгоритъма във възходящ ред.
    Идея на метода
    - обхождаме масива от a[0] до a[n-1], намираме най-малкия елемент и го
      разменяме с а[0]. ...
+ Стандартен метод за сортиране
#+begin_src csharp
Array.Sort(int[] arr);
Array.Sort(int[] arr, int startIndex, int num);
#+end_src

* Работа със сортирани масиви
** Търсене в масив
** Двоично търсене в сортиран масив

* Сливане на сортирани масиви

* Низове
** Операции с низове
+ сливане - +
+ сравняване - s1.ComparedTo(s2);
+ превръщане в главни/малки букви - string.ToUpper()/ToLower()
+ търсене на низ в друг низ - string.IndexOf()/LastIndexOf()
+ изличане на част от низ - Substring()
+ замяна на подниз с друг - string.Repace(string1, string2)
+ разцепване на низ по разделител - string.Split(char seperator)
+ премахване на ненужни симболи от низ - string.Trim(trimCh);
** Клас Stringbuilder
Този клас изболзва предварително зададено поле от паметта, чийто размер може да
бъде динамично увеличаван.
*** Методи
+ Append() - за добавяне на поле към предварително създадена истанция на класа.
+ ToString() - преобразува редицата от знаци в низ

* Масиви от знаци
** Клас CharArray
- Прилича на масив от знаци. Този клас има подобни методи класа string но дава
  възможност и за някои допълнителни операции.
+ пренаписване на конструктора по премълчаване
+ конструктор с параметър

** Методи
+ изтриване на елемент
+ вмъкване на елемент
+ заместване на елемент

* Многомерени масиви
** Двумерен масив
- таблица от елементи от един и същи тип. Всеки елемент има два индекса -
  първият обозначава реда, а вторият - колоната.

  Масив х[i,j];
  |       | Колона 0 | Колона 1 | Колона 2 |
  |-------+----------+----------+----------|
  | ред 0 | х[0,0]   | x[0,1]   | x[0,2]   |
  | ред 1 | x[1,0]   | x[1,1]   | x[1,2]   |
  | ред 2 | x[2,0]   | x[2,1]   | x[2,2]   |

  + главен диагонал - само при квадратни масиви. При него i = j
  + второстепенен/обратен диагонал. При него i+j = n-1
  + елементи над главен диагонал -
  + елементи под главен диагонал
** Деклариране на двумерен масив и заделяне на памет
<тип>[,] <име> = new <тип>[,];
#+begin_src csharp
int[,] 2DArray = new int[3,3];
#+end_src

** Инициализация на двумерен масив
+ при деклариране на масива
#+begin_src csharp
int[,] 2DArray = {{1,2,3}, {4,5,6},{7,8,9}};
#+end_src
+ въвеждане от потребител
#+begin_src csharp
for (int i = 0; i < n; i++)
    for (int j = 0; j < m; j++)
        x[i,j] = int.Parse(Console.ReadLine());
#+end_src

** Обхождане на двумерен масив
#+begin_src csharp
for (int i = 0; i < n; i++)
    for (int j = 0; j < m; j++)
        if(x[i,j] % 2 == 0)br++;
#+end_src

** Извеждане на двумерен масив
#+begin_src csharp
for (int i = 0; i < n; i++)
    for (int j = 0; j < m; j++)
        Console.Write(x[i,j]);
Console.WriteLine();
#+end_src

* Абстрактни типове данни
** Какво е абстрактен тип
тип създаден от програмиста
** дефиниране на абстрактен тип
+ трябва да се дефинират елементите и възможните операции със стойности от типа
#+begin_src csharp
class fraction
#+end_src
** Реализация на абстрактен тип
+ статична - това са типове, чиито стойности се разпологат в статични структури от данни
+ динамична - типове, размерите на чиито стойности могат да се изменят в процеса на работа
** Програмиране с абстрактни типове данни

* Вградени абстрактни типове в c#
** Колекции
+ Обединяват под общо име редица от елемени, които може и да не са от един и същ
  тип. Те са динамични и техните методи могат да увеличават или намаляват
  размерите им.
** Видове колекции
+ генерични - съдържат еднотипни данни
+ негенерични - могат да съдържат
** Пространство от имена
+ System.Collections
+ System.Collections.Generic
** Елементи на колекция
+ имат свои идентифициращи стойности в рамките на колекцията
+ имат свои индекс
** Колекция ArrayList
+ дефиниране на обект
#+begin_src csharp
ArrayList arrayList = new ArrayList();
#+end_src
+ инициализация
#+begin_src csharp
var arrayList = new ArrayList() {"11a", 1, ,'c'};
#+end_src
+ въвеждане на стройности
#+begin_src csharp
arrayList.Add("num");
arrayList[1] = 5;
#+end_src
+ вмъкване на стойности
#+begin_src csharp
arrayList.Insert(pos: 3, el: "class");
arrayList.InsertRange(pos: 3, listOfElements: {"one", 1, true})
#+end_src
+ изтриване на елементи
#+begin_src csharp
arrayList.Remove(el: "11a");
arrayList.RemoveAt(pos: 3);
arrayList.RemoveRange(startPos: 2, numOfElements: 4);
#+end_src
+ други методи
#+begin_src csharp
arrayList.Contains("11a");
arrayList.Sort();
arrayList.Reverse();
arrayList.Clear();
#+end_src

* Списъци
** Колекция List
- генерична колекция
+ създаване на инстанция на класа
#+begin_src csharp
List<int> li = new List<int>();
#+end_src
+ инициализация
#+begin_src csharp
List<int> li = new List<int>() {1,4,2,3};
li[0] = 1; li[1] = 4; li[2] = 2; li[3] = 3;
#+end_src
+ методи
#+begin_src csharp
li.Add(7);
li.AddRange({});
li.Insert(pos: 7, el: 23);
li.Insert(pos: 9, collection: new int[] {1,2,3});
li.Remove(5);
li.RemoveAt(pos: 3);
li.RemoveRange(pos: 0, num: 3);
li.Contains(8);
li.Clear();
li.IndexOf(10, [startPos: 3]);
li.LastIndexOf(5, [startPos: 10]);
li.ToArray();
li.Sort();
li.Reverse();
li.CopyTo(array: arr, pos: 6);
#+end_src

** Колекция SortedList
- Елементите на колекцията са двойки ключ-стойности
+ създаване на инстанция на класа
#+begin_src csharp
SortedList<string, int> sli = new SortedList<string, int>();
#+end_src
+ методи

* Опашка
** Дефиниция
- последователност от еднотипни елементи. При добавяне на елемент към опашката,
  той се добавя в края на опашката. При изтриване на елемент от опашката се
  изтрива първият елемент. Имаме достъп до първия елемент на опашката.
** Статична реализация
** Вграден клас Queue<Т>
+ създаване на инстанция на класа
#+begin_src csharp
Queue<int> myQueue = new Queue<int>();
#+end_src
+ методи
#+begin_src csharp
q.Count; // number of elements
q.Size(); // number of elements
q.Enqueue(el); // adds element to the queue
q.Dequeue(); // removes the head element from the queue and returns it
q.TryDequeue(out el); // tries to dequeue()
q.Peek(); // returns the head of the queue
q.TryPeek(); // tries to peek()
#+end_src

* Стек
** Дефиниция
- последователност от еднотипни елементи. При добавяне на елемент към стек, той
  се добавя въе върха на стека. При изтриване на елемент от стека се изтрива
  последния елемент. Имаме достъп до последния елемент на опащката.
** Статична реализаци
** Вграден клас Stack<T>
+ създаване на инстанция на класа
#+begin_src csharp
Stack<int> myStack = new Stack<int>();
#+end_src
+ методи
#+begin_src csharp
s.Count; // number of elements
s.Size(); // returns the size of the stack
s.Push(el); // add element to the stack
s.Pop(); // removes and returns the top element
s.Peek(); // returns the top element
s.ToArray(); // return an array with the elements;
s.CopyTo(array, index); // copies the elements of the stack to array starting from index
s.Contains(el); // return whether the el is in the stack
s.Clear(); // most powerful methods of them all
#+end_src

* Множества
** Понятието множество
- състои се от елементи
** Симбовли
+ ∈ - а ∈ А - принадлежи
+ ∉ - а ∉ А - не принадлежи
+ ⊆ - Б ⊆ А - подмножество
** Визуализация на множество
- Вен диаграми / кръгове на Ойлер
** Характеристика
- Множества са обекти в които няма наредба на елементи и няма повтаряне на
  елементите.
** Операции
+ обединение на две множества
+ сечение на две множества
+ допълнение
** Представяне
- списък на елементите
